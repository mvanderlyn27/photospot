create extension if not exists "fuzzystrmatch" with schema "extensions";

create extension if not exists "http" with schema "extensions";

create extension if not exists "postgis" with schema "extensions";


create type "public"."db_roles" as enum ('user', 'admin');

create type "public"."themes" as enum ('dark', 'light', 'device');

create table "public"."betaEmailList" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "email" text not null
);


alter table "public"."betaEmailList" enable row level security;

create table "public"."photoshot_likes" (
    "photoshot_id" bigint not null,
    "created_at" timestamp with time zone not null default now(),
    "created_by" uuid not null default auth.uid(),
    "like_type" integer not null
);


alter table "public"."photoshot_likes" enable row level security;

create table "public"."photoshot_tags" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "tag_id" bigint not null
);


alter table "public"."photoshot_tags" enable row level security;

create table "public"."photoshots" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "photospot_id" bigint not null,
    "name" text not null,
    "recreate_text" text not null,
    "photo_paths" text[] not null default '{}'::text[],
    "created_by" uuid default auth.uid()
);


alter table "public"."photoshots" enable row level security;

create table "public"."photospot_reviews" (
    "created_at" timestamp with time zone not null default now(),
    "created_by" uuid not null,
    "rating" real not null,
    "text" text,
    "photospot_id" bigint not null,
    "edited" boolean not null default false,
    "id" bigint generated by default as identity not null
);


alter table "public"."photospot_reviews" enable row level security;

create table "public"."photospots" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "created_by" uuid,
    "location" geography(Point,4326) not null,
    "neighborhood" text not null,
    "location_name" text not null,
    "address" text
);


alter table "public"."photospots" enable row level security;

create table "public"."profiles" (
    "created_at" timestamp with time zone not null default now(),
    "username" text,
    "id" uuid not null,
    "private" boolean not null default false
);


alter table "public"."profiles" enable row level security;

create table "public"."profiles_priv" (
    "id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "role" db_roles not null default 'user'::db_roles,
    "theme" themes not null default 'light'::themes
);


alter table "public"."profiles_priv" enable row level security;

create table "public"."saved_photoshots" (
    "id" uuid not null default auth.uid(),
    "created_at" timestamp with time zone not null default now(),
    "photoshot_id" bigint not null
);


alter table "public"."saved_photoshots" enable row level security;

create table "public"."saved_photospots" (
    "id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "photospot" bigint not null
);


alter table "public"."saved_photospots" enable row level security;

create table "public"."tags" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null
);


alter table "public"."tags" enable row level security;

CREATE UNIQUE INDEX "betaEmailList_pkey" ON public."betaEmailList" USING btree (id);

CREATE UNIQUE INDEX photoshot_likes_pkey ON public.photoshot_likes USING btree (photoshot_id, created_by);

CREATE UNIQUE INDEX photospot_reviews_pkey ON public.photospot_reviews USING btree (created_by, photospot_id);

CREATE UNIQUE INDEX photospot_tags_pkey ON public.photoshot_tags USING btree (id, tag_id);

CREATE UNIQUE INDEX photospots_location_key ON public.photospots USING btree (location);

CREATE UNIQUE INDEX photospots_location_name_key ON public.photospots USING btree (location_name);

CREATE UNIQUE INDEX photospots_photobook_pictures_pkey ON public.photoshots USING btree (id);

CREATE UNIQUE INDEX photospots_pkey ON public.photospots USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX profiles_priv_pkey ON public.profiles_priv USING btree (id);

CREATE UNIQUE INDEX saved_photoshots_pkey ON public.saved_photoshots USING btree (id, photoshot_id);

CREATE UNIQUE INDEX saved_photospots_pkey ON public.saved_photospots USING btree (id, photospot);

CREATE UNIQUE INDEX tags_name_key ON public.tags USING btree (name);

CREATE UNIQUE INDEX tags_pkey ON public.tags USING btree (id);

alter table "public"."betaEmailList" add constraint "betaEmailList_pkey" PRIMARY KEY using index "betaEmailList_pkey";

alter table "public"."photoshot_likes" add constraint "photoshot_likes_pkey" PRIMARY KEY using index "photoshot_likes_pkey";

alter table "public"."photoshot_tags" add constraint "photospot_tags_pkey" PRIMARY KEY using index "photospot_tags_pkey";

alter table "public"."photoshots" add constraint "photospots_photobook_pictures_pkey" PRIMARY KEY using index "photospots_photobook_pictures_pkey";

alter table "public"."photospot_reviews" add constraint "photospot_reviews_pkey" PRIMARY KEY using index "photospot_reviews_pkey";

alter table "public"."photospots" add constraint "photospots_pkey" PRIMARY KEY using index "photospots_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."profiles_priv" add constraint "profiles_priv_pkey" PRIMARY KEY using index "profiles_priv_pkey";

alter table "public"."saved_photoshots" add constraint "saved_photoshots_pkey" PRIMARY KEY using index "saved_photoshots_pkey";

alter table "public"."saved_photospots" add constraint "saved_photospots_pkey" PRIMARY KEY using index "saved_photospots_pkey";

alter table "public"."tags" add constraint "tags_pkey" PRIMARY KEY using index "tags_pkey";

alter table "public"."photoshot_likes" add constraint "photoshot_likes_created_by_fkey" FOREIGN KEY (created_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."photoshot_likes" validate constraint "photoshot_likes_created_by_fkey";

alter table "public"."photoshot_likes" add constraint "photoshot_likes_photoshot_id_fkey" FOREIGN KEY (photoshot_id) REFERENCES photoshots(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."photoshot_likes" validate constraint "photoshot_likes_photoshot_id_fkey";

alter table "public"."photoshot_tags" add constraint "photoshot_tags_id_fkey" FOREIGN KEY (id) REFERENCES photoshots(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."photoshot_tags" validate constraint "photoshot_tags_id_fkey";

alter table "public"."photoshot_tags" add constraint "photospot_tags_tag_id_fkey" FOREIGN KEY (tag_id) REFERENCES tags(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."photoshot_tags" validate constraint "photospot_tags_tag_id_fkey";

alter table "public"."photoshots" add constraint "photoshots_created_by_fkey" FOREIGN KEY (created_by) REFERENCES profiles(id) not valid;

alter table "public"."photoshots" validate constraint "photoshots_created_by_fkey";

alter table "public"."photoshots" add constraint "photoshots_photospot_id_fkey" FOREIGN KEY (photospot_id) REFERENCES photospots(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."photoshots" validate constraint "photoshots_photospot_id_fkey";

alter table "public"."photospot_reviews" add constraint "photospot_reviews_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."photospot_reviews" validate constraint "photospot_reviews_created_by_fkey";

alter table "public"."photospot_reviews" add constraint "photospot_reviews_created_by_fkey1" FOREIGN KEY (created_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."photospot_reviews" validate constraint "photospot_reviews_created_by_fkey1";

alter table "public"."photospot_reviews" add constraint "photospot_reviews_photospot_id_fkey" FOREIGN KEY (photospot_id) REFERENCES photospots(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."photospot_reviews" validate constraint "photospot_reviews_photospot_id_fkey";

alter table "public"."photospot_reviews" add constraint "photospot_reviews_rating_check" CHECK ((rating <= (5)::double precision)) not valid;

alter table "public"."photospot_reviews" validate constraint "photospot_reviews_rating_check";

alter table "public"."photospots" add constraint "photospots_location_key" UNIQUE using index "photospots_location_key";

alter table "public"."photospots" add constraint "photospots_location_name_key" UNIQUE using index "photospots_location_name_key";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."profiles_priv" add constraint "profiles_priv_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."profiles_priv" validate constraint "profiles_priv_id_fkey";

alter table "public"."saved_photoshots" add constraint "saved_photoshots_id_fkey" FOREIGN KEY (id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."saved_photoshots" validate constraint "saved_photoshots_id_fkey";

alter table "public"."saved_photoshots" add constraint "saved_photoshots_photoshot_id_fkey" FOREIGN KEY (photoshot_id) REFERENCES photoshots(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."saved_photoshots" validate constraint "saved_photoshots_photoshot_id_fkey";

alter table "public"."saved_photospots" add constraint "saved_photospots_id_fkey" FOREIGN KEY (id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."saved_photospots" validate constraint "saved_photospots_id_fkey";

alter table "public"."saved_photospots" add constraint "saved_photospots_photospot_fkey" FOREIGN KEY (photospot) REFERENCES photospots(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."saved_photospots" validate constraint "saved_photospots_photospot_fkey";

alter table "public"."tags" add constraint "tags_name_key" UNIQUE using index "tags_name_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_photospot_with_lat_lng(location_namein text, addressin text, neighborhoodin text, locationin geometry)
 RETURNS TABLE(id bigint, location_name text, address text, neighborhood text, lat double precision, lng double precision)
 LANGUAGE plpgsql
AS $function$
DECLARE
    new_id bigint;
BEGIN
    INSERT INTO photospots (location_name, address, neighborhood, location)
    VALUES (location_nameIn, addressIn, neighborhoodIn, locationIn)
    RETURNING photospots.id INTO new_id;

    RETURN QUERY
    SELECT
        photospots.id,
        photospots.location_name,
        photospots.address,
        photospots.neighborhood,
        ST_Y(photospots.location::geometry) as lat,
        ST_X(photospots.location::geometry) as lng
    FROM photospots
    WHERE photospots.id = new_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_random_user()
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    random_user jsonb;
    email text;
    password text;
    user_metadata jsonb;
    uuid text;
BEGIN
    -- Get random user data from get_random_user function
    random_user := get_random_user();

    -- Extract email from random user data
    email := random_user->>'email';

    -- Generate a random password (8 to 14 characters alphanumeric)
    password := generate_random_password((floor(random() * 7) + 8)::integer);

   

    -- Extract relevant fields to create user metadata
    user_metadata := jsonb_build_object(
        'password', password,
        'username' , random_user->'login'->>'username',
        'name', concat(random_user->'name'->>'first', ' ', random_user->'name'->>'last'),
        'birthdate', to_char((random_user->'dob'->>'date')::timestamp, 'YYYY-MM-DD'),
        'given_name', random_user->'name'->>'first',
        'family_name', random_user->'name'->>'last',
        'middle_name', '',
        'gender',random_user->>'gender'
    );

    -- Call create_user_metadata to create the user
    uuid := create_user_metadata(email, password, user_metadata);

    -- Return the user information in the specified format using concat()
    -- RETURN concat(user_metadata->>'name', ' <', email, '>: ', password);
    RETURN uuid;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_test_user(email text, password text, metadata jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$BEGIN
  IF EXISTS (SELECT 1 FROM profiles_priv WHERE id = auth.uid() AND role = 'admin') THEN
    INSERT INTO auth.users (email, password, raw_user_meta_data) VALUES (email, password, metadata);
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_user_metadata(email text, password text, user_meta_data jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
  declare
  user_id uuid;
  encrypted_pw text;
BEGIN
  user_id := gen_random_uuid();
  encrypted_pw := crypt(password, gen_salt('bf'));
  
  INSERT INTO auth.users
    (instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, recovery_sent_at, last_sign_in_at, raw_app_meta_data, raw_user_meta_data, created_at, updated_at, confirmation_token, email_change, email_change_token_new, recovery_token)
  VALUES
    ('00000000-0000-0000-0000-000000000000', user_id, 'authenticated', 'authenticated', email, encrypted_pw, now(), now(), now(), '{"provider":"email","providers":["email"]}', user_meta_data, now(), now(), '', '', '', '');
  
  INSERT INTO auth.identities (id, user_id, identity_data, provider, last_sign_in_at, created_at, updated_at)
  VALUES
    (gen_random_uuid(), user_id, format('{"sub":"%s","email":"%s"}', user_id::text, email)::jsonb, 'email', now(), now(), now());

  RETURN user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.delete_current_user()
 RETURNS void
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
   delete from auth.users where id = auth.uid();
$function$
;

CREATE OR REPLACE FUNCTION public.delete_old_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  delete from public.profiles where id = old.id;
  delete from public.profiles_priv where id = old.id;
  return old;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.delete_storage_object(bucket text, object text, OUT status integer, OUT content character varying)
 RETURNS record
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  project_url varchar := 'https://vkfbzrfveygdqsqyiggk.supabase.co';
  service_role_key varchar := 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZrZmJ6cmZ2ZXlnZHFzcXlpZ2drIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTY3NDY3NDk1MSwiZXhwIjoxOTkwMjUwOTUxfQ.8yo7eU-Q9OkYb5DjlDBb1qIpBJEyqwwmdU9Ed10WA1M'; --  full access needed
  url varchar := project_url||'/storage/v1/object/'||bucket||'/'||object;
begin
  select
      into status, content
           result.status::int, result.content::varchar
      FROM extensions.http((
    'DELETE',
    url,
    ARRAY[extensions.http_header('authorization','Bearer '||service_role_key)],
    NULL,
    NULL)::extensions.http_request) as result;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.find_most_liked_photoshot(input_id bigint)
 RETURNS photoshots
 LANGUAGE plpgsql
AS $function$
DECLARE
    most_liked_photoshot photoshots;
BEGIN
    SELECT p.*
    INTO most_liked_photoshot
    FROM photoshots p
    JOIN (
        SELECT photoshot_id, COUNT(*) as like_count
        FROM photoshot_likes
        WHERE photoshot_id IN (
            SELECT id
            FROM photoshots
            WHERE photospot_id = input_id
        )
        GROUP BY photoshot_id
        ORDER BY like_count DESC
        LIMIT 1
    ) pl ON p.id = pl.photoshot_id;

    IF most_liked_photoshot IS NULL THEN
        SELECT *
        INTO most_liked_photoshot
        FROM photoshots
        WHERE photospot_id = input_id
        ORDER BY id
        LIMIT 1;
    END IF;

    RETURN most_liked_photoshot;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.find_photospot_by_lat_lng(latitude double precision, longitude double precision)
 RETURNS TABLE(id bigint, location_name text, address text, neighborhood text, lat double precision, lng double precision)
 LANGUAGE plpgsql
AS $function$ 
begin 
  return query
    SELECT 
      photospots.id, 
      photospots.location_name,
      photospots.address, 
      photospots.neighborhood, 
      ST_Y(photospots.location::geometry) as lat, 
      ST_X(photospots.location::geometry) as lng 
    FROM photospots WHERE
  ST_X(photospots.location::geometry) BETWEEN longitude - 0.0001 AND longitude  + 0.0001
  AND ST_Y(photospots.location::geometry) BETWEEN latitude - 0.0001 AND latitude  + 0.0001; 
END; 
$function$
;

CREATE OR REPLACE FUNCTION public.generate_random_password(length integer)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    characters text;
    password text := '';
    i integer;
BEGIN
    characters := 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

    FOR i IN 1..length LOOP
        password := password || substr(characters, (random() * length(characters) + 1)::integer, 1);
    END LOOP;

    RETURN password;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_all_photospots_with_lat_lng()
 RETURNS TABLE(id bigint, location_name text, address text, neighborhood text, lat double precision, lng double precision)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        photospots.id,
        photospots.location_name,
        photospots.address,
        photospots.neighborhood,
        ST_Y(photospots.location::geometry) as lat,
        ST_X(photospots.location::geometry) as lng
    FROM photospots;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_photospot_by_id_lat_lng(input_id bigint)
 RETURNS TABLE(id bigint, location_name text, address text, neighborhood text, lat double precision, lng double precision)
 LANGUAGE plpgsql
AS $function$
begin
    return query
    SELECT
        photospots.id,
        photospots.location_name,
        photospots.address,
        photospots.neighborhood,
        ST_Y(photospots.location::geometry) as lat,
        ST_X(photospots.location::geometry) as lng
    FROM photospots
    WHERE photospots.id = input_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_random_user()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    response jsonb;
BEGIN

   select content::json->'results'->0
   into response
   from http_get('https://randomuser.me/api/');

   return response::jsonb;

END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_tags_for_photospot(photospotid bigint)
 RETURNS SETOF text
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT DISTINCT t.name
    FROM tags t
    JOIN photoshot_tags pt ON t.id = pt.tag_id
    JOIN photoshots p ON pt.id = p.id
    WHERE p.photospot_id = photospotid;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  insert into public.profiles_priv (id)
  values (new.id);
  insert into public.profiles (id, username)
  values (new.id, new.raw_user_meta_data->>'username');
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.nearby_photospots(latt double precision, long double precision)
 RETURNS TABLE(id bigint, location_name text, neighborhood text, lat double precision, lng double precision, dist_meters double precision)
 LANGUAGE sql
AS $function$
  select photospots.id, photospots.location_name, photospots.neighborhood, st_y(photospots.location::geometry) as lat, st_x(photospots.location::geometry) as lng, st_distance(location, st_point(long, latt)::geography) as dist_meters
  from photospots
  order by photospots.location <-> st_point(long, latt)::geography;
$function$
;

CREATE OR REPLACE FUNCTION public.photoshot_like_count(input_id bigint)
 RETURNS bigint
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN (
        SELECT SUM(like_type)
        FROM photoshot_likes
        WHERE photoshot_id = input_id
    );
END;
$function$
;

create or replace view "public"."photospot_rating_stats" as  SELECT p.id,
    avg(r.rating) AS rating_average,
    count(r.rating) AS rating_count
   FROM (photospots p
     LEFT JOIN photospot_reviews r ON ((p.id = r.photospot_id)))
  GROUP BY p.id;


CREATE OR REPLACE FUNCTION public.photospots_in_view(min_lat double precision, min_long double precision, max_lat double precision, max_long double precision)
 RETURNS TABLE(id bigint, name text, lat double precision, long double precision)
 LANGUAGE sql
AS $function$select id, name, st_y(location::geometry) as lat, st_x(location::geometry) as long
from public.photospots
where location && ST_SetSRID(ST_MakeBox2D(ST_Point(min_long, min_lat), ST_Point(max_long, max_lat)), 4326)$function$
;

CREATE OR REPLACE FUNCTION public.profiles_columns_updateable()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$BEGIN
  IF NEW.roles <> OLD.roles THEN
    RAISE EXCEPTION 'changing "roles" is not allowed';
  END IF;

  RETURN NEW;
END;$function$
;

CREATE OR REPLACE FUNCTION public.search_tags(input_text text)
 RETURNS TABLE(id bigint, name text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF input_text = '' THEN
        RETURN QUERY
        SELECT tags.id, tags.name
        FROM tags;
    ELSE
        RETURN QUERY
        SELECT tags.id, tags.name
        FROM tags
        WHERE lower(tags.name) LIKE '%' || lower(input_text) || '%'  
        UNION
        SELECT tags.id, tags.name
        FROM tags
        WHERE levenshtein(lower(tags.name), lower(input_text)) <= 2;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_photoshot_tags(photoshot_id bigint, tag_ids bigint[])
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Delete entries not in the tag_ids list
    DELETE FROM photoshot_tags
    WHERE photoshot_tags.id = photoshot_id
    AND photoshot_tags.tag_id NOT IN (SELECT unnest(tag_ids));
    
    -- Insert new entries from the tag_ids list
    INSERT INTO photoshot_tags (id, tag_id)
    SELECT photoshot_id, tag_id
    FROM unnest(tag_ids) AS tag_id
    ON CONFLICT DO NOTHING;
    
END;
$function$
;

grant delete on table "public"."betaEmailList" to "anon";

grant insert on table "public"."betaEmailList" to "anon";

grant references on table "public"."betaEmailList" to "anon";

grant select on table "public"."betaEmailList" to "anon";

grant trigger on table "public"."betaEmailList" to "anon";

grant truncate on table "public"."betaEmailList" to "anon";

grant update on table "public"."betaEmailList" to "anon";

grant delete on table "public"."betaEmailList" to "authenticated";

grant insert on table "public"."betaEmailList" to "authenticated";

grant references on table "public"."betaEmailList" to "authenticated";

grant select on table "public"."betaEmailList" to "authenticated";

grant trigger on table "public"."betaEmailList" to "authenticated";

grant truncate on table "public"."betaEmailList" to "authenticated";

grant update on table "public"."betaEmailList" to "authenticated";

grant delete on table "public"."betaEmailList" to "service_role";

grant insert on table "public"."betaEmailList" to "service_role";

grant references on table "public"."betaEmailList" to "service_role";

grant select on table "public"."betaEmailList" to "service_role";

grant trigger on table "public"."betaEmailList" to "service_role";

grant truncate on table "public"."betaEmailList" to "service_role";

grant update on table "public"."betaEmailList" to "service_role";

grant delete on table "public"."photoshot_likes" to "anon";

grant insert on table "public"."photoshot_likes" to "anon";

grant references on table "public"."photoshot_likes" to "anon";

grant select on table "public"."photoshot_likes" to "anon";

grant trigger on table "public"."photoshot_likes" to "anon";

grant truncate on table "public"."photoshot_likes" to "anon";

grant update on table "public"."photoshot_likes" to "anon";

grant delete on table "public"."photoshot_likes" to "authenticated";

grant insert on table "public"."photoshot_likes" to "authenticated";

grant references on table "public"."photoshot_likes" to "authenticated";

grant select on table "public"."photoshot_likes" to "authenticated";

grant trigger on table "public"."photoshot_likes" to "authenticated";

grant truncate on table "public"."photoshot_likes" to "authenticated";

grant update on table "public"."photoshot_likes" to "authenticated";

grant delete on table "public"."photoshot_likes" to "service_role";

grant insert on table "public"."photoshot_likes" to "service_role";

grant references on table "public"."photoshot_likes" to "service_role";

grant select on table "public"."photoshot_likes" to "service_role";

grant trigger on table "public"."photoshot_likes" to "service_role";

grant truncate on table "public"."photoshot_likes" to "service_role";

grant update on table "public"."photoshot_likes" to "service_role";

grant delete on table "public"."photoshot_tags" to "anon";

grant insert on table "public"."photoshot_tags" to "anon";

grant references on table "public"."photoshot_tags" to "anon";

grant select on table "public"."photoshot_tags" to "anon";

grant trigger on table "public"."photoshot_tags" to "anon";

grant truncate on table "public"."photoshot_tags" to "anon";

grant update on table "public"."photoshot_tags" to "anon";

grant delete on table "public"."photoshot_tags" to "authenticated";

grant insert on table "public"."photoshot_tags" to "authenticated";

grant references on table "public"."photoshot_tags" to "authenticated";

grant select on table "public"."photoshot_tags" to "authenticated";

grant trigger on table "public"."photoshot_tags" to "authenticated";

grant truncate on table "public"."photoshot_tags" to "authenticated";

grant update on table "public"."photoshot_tags" to "authenticated";

grant delete on table "public"."photoshot_tags" to "service_role";

grant insert on table "public"."photoshot_tags" to "service_role";

grant references on table "public"."photoshot_tags" to "service_role";

grant select on table "public"."photoshot_tags" to "service_role";

grant trigger on table "public"."photoshot_tags" to "service_role";

grant truncate on table "public"."photoshot_tags" to "service_role";

grant update on table "public"."photoshot_tags" to "service_role";

grant delete on table "public"."photoshots" to "anon";

grant insert on table "public"."photoshots" to "anon";

grant references on table "public"."photoshots" to "anon";

grant select on table "public"."photoshots" to "anon";

grant trigger on table "public"."photoshots" to "anon";

grant truncate on table "public"."photoshots" to "anon";

grant update on table "public"."photoshots" to "anon";

grant delete on table "public"."photoshots" to "authenticated";

grant insert on table "public"."photoshots" to "authenticated";

grant references on table "public"."photoshots" to "authenticated";

grant select on table "public"."photoshots" to "authenticated";

grant trigger on table "public"."photoshots" to "authenticated";

grant truncate on table "public"."photoshots" to "authenticated";

grant update on table "public"."photoshots" to "authenticated";

grant delete on table "public"."photoshots" to "service_role";

grant insert on table "public"."photoshots" to "service_role";

grant references on table "public"."photoshots" to "service_role";

grant select on table "public"."photoshots" to "service_role";

grant trigger on table "public"."photoshots" to "service_role";

grant truncate on table "public"."photoshots" to "service_role";

grant update on table "public"."photoshots" to "service_role";

grant delete on table "public"."photospot_reviews" to "anon";

grant insert on table "public"."photospot_reviews" to "anon";

grant references on table "public"."photospot_reviews" to "anon";

grant select on table "public"."photospot_reviews" to "anon";

grant trigger on table "public"."photospot_reviews" to "anon";

grant truncate on table "public"."photospot_reviews" to "anon";

grant update on table "public"."photospot_reviews" to "anon";

grant delete on table "public"."photospot_reviews" to "authenticated";

grant insert on table "public"."photospot_reviews" to "authenticated";

grant references on table "public"."photospot_reviews" to "authenticated";

grant select on table "public"."photospot_reviews" to "authenticated";

grant trigger on table "public"."photospot_reviews" to "authenticated";

grant truncate on table "public"."photospot_reviews" to "authenticated";

grant update on table "public"."photospot_reviews" to "authenticated";

grant delete on table "public"."photospot_reviews" to "service_role";

grant insert on table "public"."photospot_reviews" to "service_role";

grant references on table "public"."photospot_reviews" to "service_role";

grant select on table "public"."photospot_reviews" to "service_role";

grant trigger on table "public"."photospot_reviews" to "service_role";

grant truncate on table "public"."photospot_reviews" to "service_role";

grant update on table "public"."photospot_reviews" to "service_role";

grant delete on table "public"."photospots" to "anon";

grant insert on table "public"."photospots" to "anon";

grant references on table "public"."photospots" to "anon";

grant select on table "public"."photospots" to "anon";

grant trigger on table "public"."photospots" to "anon";

grant truncate on table "public"."photospots" to "anon";

grant update on table "public"."photospots" to "anon";

grant delete on table "public"."photospots" to "authenticated";

grant insert on table "public"."photospots" to "authenticated";

grant references on table "public"."photospots" to "authenticated";

grant select on table "public"."photospots" to "authenticated";

grant trigger on table "public"."photospots" to "authenticated";

grant truncate on table "public"."photospots" to "authenticated";

grant update on table "public"."photospots" to "authenticated";

grant delete on table "public"."photospots" to "service_role";

grant insert on table "public"."photospots" to "service_role";

grant references on table "public"."photospots" to "service_role";

grant select on table "public"."photospots" to "service_role";

grant trigger on table "public"."photospots" to "service_role";

grant truncate on table "public"."photospots" to "service_role";

grant update on table "public"."photospots" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";

grant delete on table "public"."profiles_priv" to "anon";

grant insert on table "public"."profiles_priv" to "anon";

grant references on table "public"."profiles_priv" to "anon";

grant select on table "public"."profiles_priv" to "anon";

grant trigger on table "public"."profiles_priv" to "anon";

grant truncate on table "public"."profiles_priv" to "anon";

grant update on table "public"."profiles_priv" to "anon";

grant delete on table "public"."profiles_priv" to "authenticated";

grant insert on table "public"."profiles_priv" to "authenticated";

grant references on table "public"."profiles_priv" to "authenticated";

grant select on table "public"."profiles_priv" to "authenticated";

grant trigger on table "public"."profiles_priv" to "authenticated";

grant truncate on table "public"."profiles_priv" to "authenticated";

grant update on table "public"."profiles_priv" to "authenticated";

grant delete on table "public"."profiles_priv" to "service_role";

grant insert on table "public"."profiles_priv" to "service_role";

grant references on table "public"."profiles_priv" to "service_role";

grant select on table "public"."profiles_priv" to "service_role";

grant trigger on table "public"."profiles_priv" to "service_role";

grant truncate on table "public"."profiles_priv" to "service_role";

grant update on table "public"."profiles_priv" to "service_role";

grant delete on table "public"."saved_photoshots" to "anon";

grant insert on table "public"."saved_photoshots" to "anon";

grant references on table "public"."saved_photoshots" to "anon";

grant select on table "public"."saved_photoshots" to "anon";

grant trigger on table "public"."saved_photoshots" to "anon";

grant truncate on table "public"."saved_photoshots" to "anon";

grant update on table "public"."saved_photoshots" to "anon";

grant delete on table "public"."saved_photoshots" to "authenticated";

grant insert on table "public"."saved_photoshots" to "authenticated";

grant references on table "public"."saved_photoshots" to "authenticated";

grant select on table "public"."saved_photoshots" to "authenticated";

grant trigger on table "public"."saved_photoshots" to "authenticated";

grant truncate on table "public"."saved_photoshots" to "authenticated";

grant update on table "public"."saved_photoshots" to "authenticated";

grant delete on table "public"."saved_photoshots" to "service_role";

grant insert on table "public"."saved_photoshots" to "service_role";

grant references on table "public"."saved_photoshots" to "service_role";

grant select on table "public"."saved_photoshots" to "service_role";

grant trigger on table "public"."saved_photoshots" to "service_role";

grant truncate on table "public"."saved_photoshots" to "service_role";

grant update on table "public"."saved_photoshots" to "service_role";

grant delete on table "public"."saved_photospots" to "anon";

grant insert on table "public"."saved_photospots" to "anon";

grant references on table "public"."saved_photospots" to "anon";

grant select on table "public"."saved_photospots" to "anon";

grant trigger on table "public"."saved_photospots" to "anon";

grant truncate on table "public"."saved_photospots" to "anon";

grant update on table "public"."saved_photospots" to "anon";

grant delete on table "public"."saved_photospots" to "authenticated";

grant insert on table "public"."saved_photospots" to "authenticated";

grant references on table "public"."saved_photospots" to "authenticated";

grant select on table "public"."saved_photospots" to "authenticated";

grant trigger on table "public"."saved_photospots" to "authenticated";

grant truncate on table "public"."saved_photospots" to "authenticated";

grant update on table "public"."saved_photospots" to "authenticated";

grant delete on table "public"."saved_photospots" to "service_role";

grant insert on table "public"."saved_photospots" to "service_role";

grant references on table "public"."saved_photospots" to "service_role";

grant select on table "public"."saved_photospots" to "service_role";

grant trigger on table "public"."saved_photospots" to "service_role";

grant truncate on table "public"."saved_photospots" to "service_role";

grant update on table "public"."saved_photospots" to "service_role";

grant delete on table "public"."tags" to "anon";

grant insert on table "public"."tags" to "anon";

grant references on table "public"."tags" to "anon";

grant select on table "public"."tags" to "anon";

grant trigger on table "public"."tags" to "anon";

grant truncate on table "public"."tags" to "anon";

grant update on table "public"."tags" to "anon";

grant delete on table "public"."tags" to "authenticated";

grant insert on table "public"."tags" to "authenticated";

grant references on table "public"."tags" to "authenticated";

grant select on table "public"."tags" to "authenticated";

grant trigger on table "public"."tags" to "authenticated";

grant truncate on table "public"."tags" to "authenticated";

grant update on table "public"."tags" to "authenticated";

grant delete on table "public"."tags" to "service_role";

grant insert on table "public"."tags" to "service_role";

grant references on table "public"."tags" to "service_role";

grant select on table "public"."tags" to "service_role";

grant trigger on table "public"."tags" to "service_role";

grant truncate on table "public"."tags" to "service_role";

grant update on table "public"."tags" to "service_role";

create policy "Enable insert access for all users"
on "public"."betaEmailList"
as permissive
for insert
to public
with check (true);


create policy "Enable read access for all users"
on "public"."betaEmailList"
as permissive
for select
to public
using (true);


create policy "User can do everything to their own likes"
on "public"."photoshot_likes"
as permissive
for all
to public
using ((( SELECT auth.uid() AS uid) = created_by));


create policy "Creater of photospot can update its tags"
on "public"."photoshot_tags"
as permissive
for update
to public
using ((( SELECT auth.uid() AS uid) IN ( SELECT photoshots.created_by
   FROM photoshots
  WHERE (photoshot_tags.id = photoshots.id))));


create policy "Delete allowed by creater of photoshot"
on "public"."photoshot_tags"
as permissive
for delete
to public
using ((( SELECT auth.uid() AS uid) IN ( SELECT photoshots.created_by
   FROM photoshots
  WHERE (photoshot_tags.id = photoshots.id))));


create policy "Enable insert for authenticated users only"
on "public"."photoshot_tags"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."photoshot_tags"
as permissive
for select
to public
using (true);


create policy "Enable delete for users based on user_id"
on "public"."photoshots"
as permissive
for delete
to public
using ((( SELECT auth.uid() AS uid) = created_by));


create policy "Enable insert for authenticated users only"
on "public"."photoshots"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."photoshots"
as permissive
for select
to public
using (true);


create policy "Enable update for users based on user_id"
on "public"."photoshots"
as permissive
for update
to public
using ((( SELECT auth.uid() AS uid) = created_by));


create policy "Enable delete by owner"
on "public"."photospot_reviews"
as permissive
for delete
to public
using ((auth.uid() = created_by));


create policy "Enable insert for authenticated users only"
on "public"."photospot_reviews"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."photospot_reviews"
as permissive
for select
to public
using (true);


create policy "Enable update by owner"
on "public"."photospot_reviews"
as permissive
for update
to public
using ((auth.uid() = created_by));


create policy "Enable delete by owner"
on "public"."photospots"
as permissive
for delete
to public
using ((auth.uid() = created_by));


create policy "Enable insert for authenticated users only"
on "public"."photospots"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."photospots"
as permissive
for select
to public
using (true);


create policy "Enable read access for all users (may need to secure)"
on "public"."profiles"
as permissive
for select
to public
using (true);


create policy "Users can delete their own profile"
on "public"."profiles"
as permissive
for delete
to public
using ((auth.uid() = id));


create policy "Users can insert their own profile"
on "public"."profiles"
as permissive
for insert
to public
with check ((auth.uid() = id));


create policy "Users can update their profile"
on "public"."profiles"
as permissive
for update
to public
using ((auth.uid() = id));


create policy "Enable full access just to user who's account it is"
on "public"."profiles_priv"
as permissive
for all
to public
using ((auth.uid() = id));


create policy "user can do anything to their own saved"
on "public"."saved_photoshots"
as permissive
for all
to public
using ((( SELECT auth.uid() AS uid) = id));


create policy "Enable access for users based on id"
on "public"."saved_photospots"
as permissive
for all
to public
using ((( SELECT auth.uid() AS uid) = id));


create policy "Enable insert for authenticated users only"
on "public"."tags"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."tags"
as permissive
for select
to public
using (true);


CREATE TRIGGER update_role BEFORE UPDATE ON public.profiles_priv FOR EACH STATEMENT EXECUTE FUNCTION storage.update_updated_at_column();


